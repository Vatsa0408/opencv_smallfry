# -*- coding: utf-8 -*-
"""Copy of darknet

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ESXSnTH9baqQlc3j-2w8ddK2_n_bAubV

#step 1: build darknet
"""

# Commented out IPython magic to ensure Python compatibility.
!git clone https://github.com/pjreddie/darknet
# %cd /content/darknet
!ls

# patch data.c
!rm src/data.c
!rm src/yolo_layer.c
!rm src/detector.c
!rm Makefile
!cp "/content/drive/My Drive/darknet/data.c" src/data.c
!cp "/content/drive/My Drive/darknet/yolo_layer.c" src/yolo_layer.c
!cp "/content/drive/My Drive/darknet/detector.c" src/detector.c
!cp "/content/drive/My Drive/darknet/Makefile" Makefile

!mv Makefile Makefile.txt

!mv Makefile.txt Makefile

!make

!ld

!ls -l
!./darknet

"""#step 2: gather data"""

#!wget https://pjreddie.com/media/files/darknet53.conv.74 -O /content/darknet/darknet53.conv.74
#!wget https://github.com/spmallick/learnopencv/raw/master/YOLOv3-Training-Snowman-Detector/darknet-yolov3.cfg
#!wget https://github.com/spmallick/learnopencv/raw/master/YOLOv3-Training-Snowman-Detector/classes.names
#!wget https://github.com/spmallick/learnopencv/raw/master/YOLOv3-Training-Snowman-Detector/darknet.data
#!wget https://github.com/spmallick/learnopencv/raw/master/YOLOv3-Training-Snowman-Detector/getDataFromOpenImages_snowman.py
#!wget https://github.com/spmallick/learnopencv/raw/master/YOLOv3-Training-Snowman-Detector/darksplitTrainAndTest.py
###
#!wget https://pjreddie.com/media/files/yolov3.weights
#!cp yolov3.weights "/content/drive/My Drive/darknet/"

#!cp "/content/drive/My Drive/darknet/darknet53.conv.74" .
!cp "/content/drive/My Drive/darknet/yolov3.weights" .
!cp "/content/drive/My Drive/darknet/darknet-yolov3_r.cfg" .

!git clone https://github.com/pratikkayal/PlantDoc-Object-Detection-Dataset

"""#step 2b: see what we have"""

import cv2, numpy as np
net = cv2.dnn.readNet("darknet53.conv.74","darknet-yolov3_r.cfg")
dumm = np.ones((416,416,3),np.float32)
blob = cv2.dnn.blobFromImage(dumm)
print(blob.shape)
net.setInput(blob)
net.dumpToFile("darknet35.dot")

!dot darknet35.dot -Tpng -odot.png

dotim = cv2.imread("dot.png")
print(dotim.shape)
from google.colab.patches import cv2_imshow
cv2_imshow(dotim)

"""#step 3: prepare for training

conv_79 (and upwards) can be frozen by setting stopbackwards=1

https://github.com/ultralytics/yolov3/wiki/Train-Custom-Data
"""

!mv /content/darknet/PlantDoc-Object-Detection-Dataset images
!mv images/TRAIN images/train
!mv images/TEST images/test
!mkdir labels
!mkdir labels/train
!mkdir labels/test

!rm -f labels/train/*
!rm -f labels/test/*

import csv, os
    
classes = {}
def write_labels(test=False):
    if test:
        pre = "/content/darknet/images/test/"
        fname = "/content/darknet/images/test_labels.csv"
        ftname = "/content/darknet/data/plants_test.txt"
    else:
        pre = "/content/darknet/images/train/"
        fname = "/content/darknet/images/train_labels.csv"
        ftname = "/content/darknet/data/plants_train.txt"

    ftext = open(ftname,"w")

    # filename,width,height,class,xmin,ymin,xmax,ymax


    # extra pass to collect the classnames
    if not test:
      lines=0
      reader = csv.reader(open(fname, newline='', encoding='utf-8'), quotechar='"')
      for s in reader:
        lines += 1
        if lines==1: continue
        c = s[3]
        if c in classes:
          classes[c] += 1
        else:
          classes[c] = 0
      print(len(classes),"classes.")
      id=0
      for c in classes: classes[c] = id; id +=1

    lines=0
    reader = csv.reader(open(fname, newline='', encoding='utf-8'), quotechar='"')
    for s in reader:
      lines += 1
      if lines==1: continue
      # print(s[0])
      if not os.path.exists(pre + s[0]):
        print("no img",s[0])
        continue
      if s[0].find("tomatofactsheet")>-1:
        continue

      c = s[3]
      W = int(s[1])
      H = int(s[2])
      x = int(s[4])
      y = int(s[5])
      X = int(s[6])
      Y = int(s[7])
      cx = float(x) + (X-x)*0.5
      cy = float(y) + (Y-y)*0.5
      if W==0: W=X
      if H==0: H=Y
      line = " ".join([str(classes[c]),str(cx/W),str(cy/H),str((X-x)/W),str((Y-y)/H)]) + "\n"
      end=-3
      if s[0][end] == 'p': # .jpeg ;(
        end=-4
      if test:
          fn = "/content/darknet/labels/test/" + s[0][:end] + "txt"
      else:
          fn = "/content/darknet/labels/train/" + s[0][:end] + "txt"
      if fn.find(".png")>0:
        print(fn)
      f = open(fn,"a")
      f.write( line )
      f.close()
      if not os.path.exists(fn):
        print("bad write", fn)
        continue
      ftext.write(pre + s[0] + "\n")
      #print(line)

write_labels(False)
write_labels(True)

f = open("/content/darknet/data/plants.classes","w")
for c in classes:
  f.write(c + "\n")

f = open("/content/darknet/data/plants.data","w")
f.write("classes=" + str(len(classes)) + "\n")
f.write("train=/content/darknet/data/plants_train.txt\n")
f.write("valid=/content/darknet/data/plants_test.txt\n")
f.write("names=/content/darknet/data/plants.classes\n")
f.write("backup=/content/darknet/backup\n")

!cat data/plants.classes

f = open("data/plants_train.txt","r")
ff = open("data/train.list","w")
t = f.read()
s = t.split("\n")
for x in s:
  if not os.path.exists(x):
    print("no img", x)
    continue
  lab = x.replace("/content/darknet/images/train","/content/darknet/labels/train")
  lab = lab[:-3] + "txt"
  if not os.path.exists(lab):
    print("no txt", lab)
    continue
  ff.write(x + "\n")

"""#step 4: train darknet"""

! ./darknet detector train data/plants.data yolov3.cfg backup/yolov3.backup
#! ./darknet detector train data/plants.data yolov3.cfg yolov3_3700.weights
#! ./darknet detector train data/plants.data darknet-yolov3_r.cfg darknet53.conv.74

!mkdir "/content/drive/My Drive/darknet"
!mkdir "/content/drive/My Drive/darknet/backup"

!cp backup/yolov3.backup "/content/drive/My Drive/darknet/backup/yolov3_6000.weights"

"""#step 5: try with opencv dnn"""

!ls -l  "/content/drive/My Drive/darknet/backup/"
!cp  "/content/drive/My Drive/darknet/backup/yolov3_6000.weights" .

import cv2, numpy as np
import csv
import os

# taken from pyimagesearch
def bb_intersection_over_union(boxA, boxB):
	# determine the (x, y)-coordinates of the intersection rectangle
	xA = max(boxA[0], boxB[0])
	yA = max(boxA[1], boxB[1])
	xB = min(boxA[2], boxB[2])
	yB = min(boxA[3], boxB[3])
	# compute the area of intersection rectangle
	interArea = max(0, xB - xA + 1) * max(0, yB - yA + 1)
	# compute the area of both the prediction and ground-truth
	# rectangles
	boxAArea = (boxA[2] - boxA[0] + 1) * (boxA[3] - boxA[1] + 1)
	boxBArea = (boxB[2] - boxB[0] + 1) * (boxB[3] - boxB[1] + 1)
	# compute the intersection over union by taking the intersection
	# area and dividing it by the sum of prediction + ground-truth
	# areas - the interesection area
	iou = interArea / float(boxAArea + boxBArea - interArea)
	# return the intersection over union value
	return iou

id=0
classes = {}
f = open("/content/darknet/data/plants.classes","r")
s = f.read().split("\n")
for c in s:
  classes[c] = id
  id += 1


#net = cv2.dnn.readNet("backup/yolov3.backup", "yolov3.cfg")
net = cv2.dnn.readNet("yolov3_6000.weights", "yolov3.cfg")
outNames = net.getUnconnectedOutLayersNames()
print(outNames)
mAP = 0
mIOU = 0
missed=0
hits = 0 
fail = 0
lines=0
confusion = np.zeros((30,30),np.float32)
reader = csv.reader(open("images/test_labels.csv", newline='', encoding='utf-8'), quotechar='"')
for s in reader:
  lines += 1
  if lines==1: continue
  # print(s[0])
  if not os.path.exists("images/test/" + s[0]):
    print("no img",s[0])
    continue
  if s[0].find("tomatofactsheet")>-1:
    continue

  c = classes[s[3]]
  W = int(s[1])
  H = int(s[2])
  x = int(s[4])
  y = int(s[5])
  X = int(s[6])
  Y = int(s[7])
  box = [x,y,X,Y]
  
  im = cv2.imread("images/test/" + s[0])
  FW = im.shape[1]
  FH = im.shape[0]
  #print(im.shape)
  blob = cv2.dnn.blobFromImage(im, 0.00392, size=(416,416), swapRB=True)
  net.setInput(blob)
  outs = net.forward(outNames)
  confThreshold = 0.1
  nmsThreshold = 0.1
  classIds = []
  confidences = []
  boxes = []
  for out in outs:
      for detection in out:
          scores = detection[5:]
          classId = np.argmax(scores)
          confidence = scores[classId]
          #print(detection)
          if confidence > confThreshold:
              center_x = int(detection[0] * FW)
              center_y = int(detection[1] * FH)
              width = int(detection[2] * FW)
              height = int(detection[3] * FH)
              left = int(center_x - width / 2)
              top = int(center_y - height / 2)
              classIds.append(classId)
              confidences.append(float(confidence))
              boxes.append([left, top, width, height])

  indices = cv2.dnn.NMSBoxes(boxes, confidences, confThreshold, nmsThreshold)
  #print()
  mi,miou = -1,-1
  for i in indices:
    i = i[0]
    iou = bb_intersection_over_union(boxes[i], box)
    if iou > miou:
      miou = iou
      mi = i
  if len(indices):
    confusion[c,classIds[mi]] += 1
    print(classIds[mi],c,miou,confidences[mi],s[0],len(boxes), len(indices), box, boxes[mi])
    if classIds[mi] == c: 
      mAP += 1
      mIOU += miou
      hits += 1
    else:
      missed += 1
  else:
    fail += 1
    print('-',c,'-',s[0], 0, 0)
    confusion[c,29] += 1
 
print("fail",fail,"missed",missed,"hits",hits,"mAP",(hits / (mAP + missed)),"mIOU",(mIOU/hits))
print(confusion)